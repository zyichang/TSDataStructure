[01. 关于线性表的顺序存储结构和链式存储结构的描述中，正确的是( )。<br>I.线性表的顺序存储结构优于其链式存储结构<br>II.链式存储结构比顺序存储结构能更方便地表示各种逻辑结构<br>III.若需频繁使用插入和删除结点操作，则顺序存储结构更优于链式存储结构<br>IV.顺序存储结构和链式存储结构都可以进行顺序存取<br>A. I,II,III<br>B. II,IV<br>C. II,III<br>D. III,IV]::(B)	两种存储结构适用于不同场合，不能简单说孰优孰劣（Ⅰ错）<br>链式存储用<strong>指针</strong>表示逻辑结构，比顺序存储更方便表示各种逻辑结构（Ⅱ对）<br>顺序存储在插入删除时需移动大量元素，效率较低（Ⅲ错）<br>顺序存储可<strong>随机存取</strong>和顺序存取，链式仅能顺序存取（Ⅳ对）	39[02. 对于一个线性表，既要求能够进行较快的插入和删除，又要求存储结构能够反映数据之间的逻辑关系，则应该用( )。<br>A. 顺序存储方式<br>B. 链式存储方式<br>C. 散列存储方式<br>D. 以上均可以]::(B)	链式存储反映<strong>数据逻辑关系</strong>，插入删除时间复杂度<anki-mathjax>O(1)</anki-mathjax><br>散列存储无法反映逻辑关系<br>顺序存储插入删除效率低	39[03. 链式存储设计时，结点内的存储单元地址( )。<br>A. 一定连续<br>B. 一定不连续<br>C. 不一定连续<br>D. 部分连续，部分不连续]::(A)	结点内存储单元地址<strong>必须连续</strong><br>不同结点存储空间可不连续	39[04. 下列关于线性表说法中，正确的是( )。<br>I.顺序存储方式只能用于存储线性结构<br>II.在一个设有头指针和尾指针的单链表中，删除表尾元素的时间复杂度与表长无关<br>III.带头结点的单循环链表中不存在空指针<br>IV.在一个长度为n的有序单链表中插入一个新结点并仍保持有序的时间复杂度为<anki-mathjax>O(n)</anki-mathjax><br>V. 若用单链表来表示队列，则应该选用带尾指针的循环链表<br>A. I,II<br>B. I,III,IV,V<br>C. IV,V<br>D. III,IV,V]::(D)	顺序存储也可存<strong>树/图</strong>（I错）<br>删除表尾元素需遍历找前驱，时间复杂度<anki-mathjax>O(n)</anki-mathjax>（II错）<br>带头结点单循环链表无<strong>空指针</strong>（III对）<br>有序单链表插入需顺序查找位置（IV对）<br>带尾指针的循环链表方便队列操作（V对）	39[05. 设线性表中有2n个元素，( )在单链表上实现要比在顺序表上实现效率更高。<br>A. 删除所有值为x的元素<br>B. 在最后一个元素的后面插入一个新元素<br>C. 顺序输出前k个元素<br>D. 交换第i个元素和第2n - i + 1个元素的值]::(A)	单链表删除值x元素时<strong>不需移动元素</strong>，顺序表需移动大量元素<br>BC操作在顺序表更高效，D操作效率相同	39[06. 在一个单链表中，已知q所指结点是p所指结点的前驱结点，若在q和p之间插入结点s，则执行( )。<br>A. s->next=p->next;p->next=s;<br>B. p->next=s->next;s->next=p;<br>C. q->next=s;s->next=p;<br>D. p->next=s;s->next=q;]::(C)	修改q的next指向s<br>s的next指向p<br>实现<strong>q→s→p</strong>的链接	41[07. 给定有n个元素的一维数组，建立一个有序单链表的最低时间复杂度是( )。<br>A. <anki-mathjax>O(1)</anki-mathjax><br>B. <anki-mathjax>O(n)</anki-mathjax><br>C. <anki-mathjax>O(n^{2})</anki-mathjax><br>D. <anki-mathjax>O(n\log n)</anki-mathjax>]::(D)	先对数组<strong>排序</strong>（最好<anki-mathjax>O(n\log n)</anki-mathjax>）<br>再建立链表（<anki-mathjax>O(n)</anki-mathjax>）<br>总时间<anki-mathjax>O(n\log n)</anki-mathjax>	41[08. 将长度为n的单链表链接在长度为m的单链表后面，其算法的时间复杂度采用大O形式表示应该是( )。<br>A. <anki-mathjax>O(1)</anki-mathjax><br>B. <anki-mathjax>O(n)</anki-mathjax><br>C. <anki-mathjax>O(m)</anki-mathjax><br>D. <anki-mathjax>O(m+n)</anki-mathjax>]::(C)	需遍历找到<strong>第一个链表尾结点</strong>（长度m）	41[09. 单链表中，增加一个头结点的目的是( )。<br>A. 使单链表至少有一个结点<br>B. 标识表结点中首结点的位置<br>C. 方便运算的实现<br>D. 说明单链表是线性表的链式存储]::(C)	使<strong>空表/非空表处理统一</strong><br>简化插入删除操作（无需特殊处理首结点）	41[10. 在一个长度为n的带头结点的单链表h上，设有尾指针r，则执行( )操作与链表的表长有关。<br>A. 删除单链表中的第一个元素<br>B. 删除单链表中的最后一个元素<br>C. 在单链表第一个元素前插入一个新元素<br>D. 在单链表最后一个元素后插入一个新元素]::(B)	删除最后一个元素需找到其前驱<strong>（遍历长度n-1）</strong>	41[11. 对于一个头指针为head的带头结点的单链表，判定该表为空表的条件是( )；对于不带头结点的单链表，判定空表的条件为( )。<br>A. head==NULL<br>B. head->next==NULL<br>C. head->next==head<br>D. head!=NULL]::(B（带头）<br>A（不带头）)	<strong>带头链表：</strong>head->next==NULL<br><strong>不带头链表：</strong>head==NULL	41[12. 在线性表<anki-mathjax>a_{0},a_{1},\cdots ,a_{100}</anki-mathjax>中，删除元素<anki-mathjax>a_{50}</anki-mathjax>需要移动( )个元素。<br>A. 0<br>B. 50<br>C. 51<br>D. 0或50]::(D)	<strong>链式存储</strong>不需移动<br><strong>顺序存储</strong>需移动后50个元素	41[13. 通过含有n(n>1)个元素的数组a，采用头插法建立单链表L，则L中的元素次序( )。<br>A. 与数组a的元素次序相同<br>B. 与数组a的元素次序相反<br>C. 与数组a的元素次序无关<br>D. 以上都错误]::(B)	头插法导致<strong>逆序存储</strong>	41[14. 下面关于线性表的一些说法中，正确的是( )。<br>A. 对一个设有头指针和尾指针的单链表执行删除最后一个元素的操作与链表长度无关<br>B. 线性表中每个元素都有一个直接前驱和一个直接后继<br>C. 为了方便插入和删除数据，可以使用双链表存放数据<br>D. 取线性表第i个元素的时间与i的大小有关]::(C)	双链表访问前驱/后继更方便<br>A需遍历找前驱（与长度相关）<br>B首尾元素不满足<br>D顺序存储取元素时间<anki-mathjax>O(1)</anki-mathjax>	41[15. 在双链表中向p所指的结点之前插入一个结点q的操作为( )。<br>A. p->prior=q;q->next=p;p->prior->next=q;q->prior=p->prior;<br>B. q->prior=p->prior;p->prior->next=q;q->next=p;p->prior=q;<br>C. q->next=p;q->prior=p->prior;p->prior->next=q;p->prior=q;<br>D. p->prior->next=q;q->next=p;q->prior=p->prior;]::(B)	关键步骤：<br>1. q->prior指向p->prior<br>2. q->next指向p<br>3. p->prior->next指向q<br>4. p->prior指向q	41[16. 在双向链表存储结构中，删除p所指的结点时必须修改指针( )。<br>A. p->prior->next=p->next;p->next->prior=p->prior;<br>B. p->next=p->prior->prior;p->prior=p;<br>C. p->prior->next=p;p->next->prior=p;<br>D. p->next=p->next->next;p->prior=p->prior->prior;]::(A)	修改前驱结点的next指向p->next<br>修改后继结点的prior指向p->prior	41[17. 在如下图所示的双链表中，已知指针p指向结点A，若要在结点A和C之间插入指针q所指的结点B，则依次执行的语句序列可以是( )。<br>①q->next=p->next;②q->prior=p;③p->next=q;④p->next->prior=q;<br>A. ①②④③<br>B. ④③②①<br>C. ③④①②<br>D. ①③④②]::(A)	顺序：先设q的后继/前驱（①②），再调整原结点关系（④③）	41[18. 在双链表的两个结点之间插入一个新结点，需要修改( )个指针域。<br>A. 1<br>B. 3<br>C. 4<br>D. 2]::(C)	新结点的prior/next<br>前驱结点的next<br>后继结点的prior	41[19. 在长度为n的有序单链表中插入一个新结点，并仍然保持有序的时间复杂度是( )。<br>A. <anki-mathjax>O(1)</anki-mathjax><br>B. <anki-mathjax>O(n)</anki-mathjax><br>C. <anki-mathjax>O(n^{2})</anki-mathjax><br>D. <anki-mathjax>O(n\log n)</anki-mathjax>]::(B)	需<strong>顺序查找</strong>插入位置（平均移动n/2次）	41[20. 与单链表相比，双链表的优点之一是( )。<br>A. 插入、删除操作更方便<br>B. 可以进行随机访问<br>C. 可以省略表头指针或表尾指针<br>D. 访问前后相邻结点更灵活]::(D)	可快速访问<strong>前驱/后继结点</strong><br>插入删除操作更复杂（需修改更多指针）	41[21. 对于一个带头结点的循环单链表L，判断该表为空表的条件是( )。<br>A. 头结点的指针域为空<br>B. L的值为NULL<br>C. 头结点的指针域与L的值相等<br>D. 头结点的指针域与L的地址相等]::(B)	L->next == L 时为空表	41[22. 对于一个带头结点的双循环链表L，判断该表为空表的条件是( )。<br>A. L->prior==L&&L->next==NULL<br>B. L->prior==NULL&&L->next==NULL<br>C. L->prior==NULL&&L->next==L<br>D. L->prior==L&&L->next==L]::(D)	头结点prior和next都指向自身	41[23. 一个链表最常用的操作是在末尾插入结点和删除结点，则选用( )最节省时间。<br>A. 带头结点的双循环链表<br>B. 单循环链表<br>C. 带尾指针的单循环链表<br>D. 单链表]::(A)	双循环链表可<strong>直接访问尾结点</strong>（通过头结点prior）	41[24. 设对n(n>1)个元素的线性表的运算只有4种：删除第一个元素；删除最后一个元素；在第一个元素之前插入新元素；在最后一个元素之后插入新元素，则最好使用( )。<br>A. 只有尾结点指针没有头结点指针的循环单链表<br>B. 只有尾结点指针没有头结点指针的非循环双链表<br>C. 只有头结点指针没有尾结点指针的循环双链表<br>D. 既有头结点指针又有尾结点指针的循环单链表]::(C)	循环双链表通过头结点可<strong>O(1)</strong>完成全部操作	41[25. 设有两个长度为n的循环单链表，若要求两个循环单链表的头尾相接的时间复杂度为<anki-mathjax>O(1)</anki-mathjax>，则对应两个循环单链表各设置一个指针，分别指向( )。<br>A. 各自的头结点<br>B. 各自的尾结点<br>C. 各自的首结点<br>D. 一个表的头结点，另一个表的尾结点]::(B)	通过<strong>尾指针</strong>可直接链接首尾	41[26. 设有一个长度为n的循环单链表，若从表中删除首元结点的时间复杂度达到<anki-mathjax>O(n)</anki-mathjax>，则此时采用的循环单链表的结构可能是( )。<br>A. 只有表头指针，没有头结点<br>B. 只有表尾指针，没有头结点<br>C. 只有表尾指针，带头结点<br>D. 只有表头指针，带头结点]::(A)	无头结点时需遍历找<strong>尾结点</strong>（前驱）	41[27. 某线性表用带头结点的循环单链表存储，头指针为head，当head->next->next==head成立时，线性表的长度可能是( )。<br>A. 0<br>B. 1<br>C. 2<br>D. 可能为0或1]::(B)	当链表只有一个元素结点时：<br>head→结点→head<br>满足条件	43[28. 有两个长度都为n的双链表，若以<anki-mathjax>h_{1}</anki-mathjax>为头指针的双链表是非循环的，以<anki-mathjax>h_{2}</anki-mathjax>为头指针的双链表是循环的，则下列叙述中正确的是( )。<br>A. 对于双链表<anki-mathjax>h_{1}</anki-mathjax>，删除首结点的时间复杂度是<anki-mathjax>O(n)</anki-mathjax><br>B. 对于双链表<anki-mathjax>h_{2}</anki-mathjax>，删除首结点的时间复杂度是<anki-mathjax>O(n)</anki-mathjax><br>C. 对于双链表<anki-mathjax>h_{1}</anki-mathjax>，删除尾结点的时间复杂度是<anki-mathjax>O(1)</anki-mathjax><br>D. 对于双链表<anki-mathjax>h_{2}</anki-mathjax>，删除尾结点的时间复杂度是<anki-mathjax>O(1)</anki-mathjax>]::(D)	循环双链表可<strong>O(1)</strong>删除首尾结点<br>非循环双链表删除尾结点需<anki-mathjax>O(n)</anki-mathjax>	43[29. 一个链表最常用的操作是在最后一个元素后插入一个元素和删除第一个元素，则选用( )最节省时间。<br>A. 不带头结点的单循环链表<br>B. 双链表<br>C. 单链表<br>D. 不带头结点且有尾指针的单循环链表]::(D)	尾指针可<strong>O(1)</strong>插入尾后<br>O(1)删除首元结点（tail->next）	43[30. 需要分配较大空间，插入和删除不需要移动元素的线性表，其存储结构为( )。<br>A. 单链表<br>B. 静态链表<br>C. 顺序表<br>D. 双链表]::(B)	<strong>静态链表</strong>特点：<br>• 预先分配连续空间<br>• 插入删除不需移动元素<br>• 用游标模拟指针	43[31. 下列关于静态链表的说法中，正确的是( )。<br>I.静态链表兼具顺序表和单链表的优点，因此存取表中第i个元素的时间与i无关<br>II.静态链表能容纳的最大元素个数在表定义时就确定了，以后不能增加<br>III.静态链表与动态链表在元素的插入、删除上类似，不需要移动元素<br>IV.相比动态链表，静态链表可能浪费较多的存储空间<br>A. I,II,III<br>B. II,III,IV<br>C. I,III,VI<br>D. I,II,VI]::(B)	I错：存取第i元素需<strong>顺序访问</strong>（与i有关）<br>II对：空间固定<br>III对：类似链表操作<br>IV对：预先分配可能浪费空间	43[32. [2016统考真题]已知一个带有表头结点的双向循环链表L，结点结构为prev data next，其中prev和next分别是指向其直接前驱和直接后继结点的指针。现要删除指针p所指的结点，正确的语句序列是( )。<br>A. p->next->prev=p->prev；p->prev->next=p->prev；free(p)；<br>B. p->next->prev=p->next；p->prev->next=p->next；free(p)；<br>C. p->next->prev=p->next；p->prev->next=p->prev；free(p)；<br>D. p->next->prev=p->prev；p->prev->next=p->next；free(p)；]::(D)	标准双链表删除操作：<br>1. 前驱结点的next指向p->next<br>2. 后继结点的prev指向p->prev	43[33. 【2016统考真题】已知带头结点的单链表头指针为head，其存储状态如下表所示。现要求将e存于1014H处并插入单链表，若e在逻辑上位于a和e之间，则a, e, e后的"链接地址"依次是( )。<br>A. 1014H, 1014H, 1004H<br>B. 1010H, 1004H, 1014H<br>C. 1014H, 1004H, 1014H<br>D. 1014H, 1004H, 1010H]::(D)	插入后链表结构应为：a → 新e(1014H) → b(1004H)。故：<br>• a的链接地址=<strong>1014H</strong>（指向新e）<br>• 新e的链接地址=<strong>1004H</strong>（指向b）<br>• 原e的链接地址=<strong>1010H</strong>（原e位置不变）	43[34. 【2021统考真题】已知头指针h指向一个带头结点的非空单循环链表，结点结构为<data,next>。其中next是指向直接后继结点的指针，p是尾指针，q是临时指针。现要删除该链表的第一个元素，正确的语句序列是( )。<br>A. h->next=h->next->next;q=h->next;free(q);<br>B. q=h->next;h->next=q->next;free(q);<br>C. q=h->next;h->next=q->next;if(p==q) p=h;free(q);<br>D. q=h->next;h->next=q->next;free(q);if(p==q) p=h;]::(D)	关键步骤：<br>1. q指向<strong>首元结点</strong>(q=h->next)<br>2. <strong>头结点指向第二个结点</strong>(h->next=q->next)<br>3. <strong>若p指向被删除结点</strong>(单结点情况)，需更新<strong>尾指针p=h</strong><br>4. <strong>释放q空间</strong>	43[35. [2023统考真题]现有非空双向链表L，其结点结构为prev data next，prev是指向直接前驱结点的指针，next是指向直接后继结点的指针。若要在L中指针p所指向的结点（非尾结点）之后插入指针s指向的新结点，则在执行语句序列"s->next=p->next；p->next=s"后，下列语句序列中还需要执行的是( )。<br>A. s->next->prev=p；s->prev=p；<br>B. p->next->prev=s；s->prev=p；<br>C. s->prev=s->next->prev；s->next->prev=s；<br>D. p->next->prev=s->prev；s->next->prev=p；]::(B)	插入双链表步骤：<br>1. s的prev指向p<br>2. 原后继结点的prev指向s	43