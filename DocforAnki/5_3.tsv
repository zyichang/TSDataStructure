[01. 在下列关于二叉树遍历的说法中，正确的是( )。<br>A. 若有一个结点是二叉树中某个子树的中序遍历结果序列的最后一个结点，则它一定是该子树的前序遍历结果序列的最后一个结点<br>B. 若有一个结点是二叉树中某个子树的前序遍历结果序列的最后一个结点，则它一定是该子树的中序遍历结果序列的最后一个结点<br>C. 若有一个叶结点是二叉树中某个子树的中序遍历结果序列的最后一个结点，则它一定是该子树的前序遍历结果序列的最后一个结点<br>D. 若有一个叶结点是二叉树中某个子树的前序遍历结果序列的最后一个结点，则它一定是该子树的中序遍历结果序列的最后一个结点]::(C)	1. 中序遍历的最后一个结点是从根沿右子女链走到底的结点（指针p）<br>2. 若p不是叶结点（左子树非空），前序遍历最后一个结点在p的左子树中（A、B错误）<br>3. 若p是叶结点，前序与中序遍历最后一个结点相同（C正确）<br>4. 若p非叶且有左子女q（叶结点），q是前序遍历最后一个结点但非中序遍历最后一个结点（D错误）	155
[02. 在任何一棵二叉树中，若结点a有左孩子b，右孩子c，则在结点的先序序列、中序序列、后序序列中，( )。<br>A. 结点b一定在结点a的前面<br>B. 结点a一定在结点c的前面<br>C. 结点b一定在结点c的前面<br>D. 结点a一定在结点b的前面]::(C)	1. <strong>遍历顺序特性</strong>：三种遍历均先左子树后右子树<br>2. b在左子树，c在极子树，因此b一定在c前访问	155
[03. 设n,m为一棵二叉树上的两个结点，在中序遍历时，n在m前的条件是( )。<br>A. n在m右方<br>B. n是m祖先<br>C. n在m左方<br>D. n是m子孙]::(C)	1. 中序遍历顺序：左子树 → 根结点 → 右子树<br>2. n在m前的三种情形：n在m的左子树中；n是m的左祖先；n和m同属某结点左子树且n在左<br>3. <strong>共同特征</strong>：n始终在m的左方	155
[04. 设n,m为一棵二叉树上的两个结点，在后序遍历时，n极m前的充分条件是( )。<br>A. n在m右方<br>B. n是m祖先<br>C. n在m左方<br>D. n是m子孙]::(D)	1. 后序遍历顺序：左子树 → 右子树 → 根结点<br>2. 充分条件：n在m的左子树中；或n是m的子孙且m在子树根位置<br>3. 反例：若n在m右方（非子孙），后序遍历顺序可能不满足条件	155
[05. 在二叉树中有两个结点m和n，若m是n的祖先，则使用( )可以找到从m到n的路径。<br>A. 先序遍历<br>B. 中序遍历<br>C. 后序遍历<br>D. 层次遍历]::(C)	1. <strong>回溯特性</strong>：后序遍历访问结点时已遍历完其子树<br>2. 路径记录：递归访问n时，栈中存储从m到n的完整路径<br>3. 操作验证：后序退回时输出结点可实现自底向上路径回溯	155
[06. 某非空二叉树采用顺序存储结构，树中的结点信息按完全二叉树的层次序列依次存在如下所示的一维数组中，则该二叉树的后序遍历序列为( )。<br>（数组：索引0→a, 1→b, 2→c, 3→d, 4→e, 5→f, 7→g, 12→h）<br>A. ghbehfca<br>B. g.bdehcfa<br>C. gdbhefca<br>D. bgdehcfa]::(C)	1. 数组下标与孩子关系：左孩子=2i+1, 右孩子=2i+2<br>2. 二叉树形态：根a（0），左孩子b（1），右孩子c（2）；b左d（3），c左e（4）右f（5）；d右g（7）；f右h（12）<br>3. 后序遍历：左→右→根 ⇒ g→d→b→h→e→f→c→a → gdbhefca	155
[07. 在二叉树的前序序列，中序序列和后序序列中，所有叶结点的先后顺序( )。<br>A. 都不相同<br>B. 完全相同<br>C. 前序和中序相同，而与后序不同<br>D. 中序和后序相同，而与前序不同]::(B)	1. <strong>核心原理</strong>：三种遍历均保持左→右子树访问顺序<br>2. 叶结点作为子树终端结点，相对位置不变<br>3. 验证：构造3结点满二叉树，遍历序列中叶结点顺序一致	155
[08. 对二叉树的结点从1开始进行连续编号，要求每个结点的编号大于其左，右孩子的编号，同一结点的左、右孩子中，其左孩子的编号小于其右孩子的编号，可采用( )次序的遍历实现编号。<br>A. 先序遍历<br>B. 中序遍历<br>C. 后序遍历<br>D. 层次遍历]::(C)	1. 编号逻辑：父结点编号需大于子结点 ⇒ 先访问子结点<br>2. 遍历顺序要求：左孩子编号 < 右孩子编号 ⇒ 先左后右<br>3. <strong>唯一匹配</strong>：后序遍历（左→右→根）自然满足条件	155
[09. 按某种顺序对二叉树的结点进行编号，编号为1,2,<anki-mathjax>\cdots</anki-mathjax>,n规定：树中任一结点v，其编号等于v的左子树上的最小编号减1，而v的右子树中的最小编号等于v的左子树上的最大编号加1，则说明该二叉树是按( )次序编号的。<br>A. 中序遍历<br>B. 先序遍历<br>C. 后序遍历<br>D. 层次遍历]::(B)	1. 编号规则：v的编号 < 左子树所有编号，且 < 右子树所有编号<br>2. 遍历含义：父结点访问在所有子结点前 ⇒ 先序遍历<br>3. 位置特征：v是子树中最早访问的结点	155
[10. 前序序列为A,B,C，后序序列为C,B,A的二叉树共有( )。<br>A. 1棵<br>B. 2棵<br>C. 3棵<br>D. 4棵]::(D)	1. 二叉树形态：前序AB...C，后序C...BA ⇒ 单支树结构<br>2. 总可能数：前序ABC的5种二叉树中，4种后序为CBA<br>3. <strong>具体示例</strong>：4种均为父结点仅一个孩子的链式结构	155
[11. 一棵完全二叉树的后序遍历序列为CDBFGEA，则其先序遍历序列是( )。<br>A. CBDAFEG<br>B. ABECDFG<br>C. ABCDEFG<br>D. 无法确定]::(C)	1. 完全二叉树特性：7结点时为3层满二叉树<br>2. 后序序列推结构：末位A为根，G为左子树根，F为右子树根<br>3. 完整重构：先序序列为<strong>ABCDEFG</strong>	155
[12. 设结点X和Y是二叉树中任意的两个结点，在该二叉树的先序遍历序列中X在Y之前，而在其后序遍历序列中X在Y之后，则X和Y的关系是( )。<br>A. X是Y的左兄弟<br>B. X是Y的右兄弟<br>C. X是Y的祖先<br>D. X是Y的后裔]::(C)	1. <strong>遍历序列逻辑</strong>：先序NLR中X在Y前 ⇒ X为祖先或左子树结点<br>2. 后序LRN中X在Y后 ⇒ X为祖先或右子树结点<br>3. 唯一交叠：X是Y的祖先	155
[13. 若二叉树中结点的先序序列是<anki-mathjax>\cdots a\cdots b\cdots</anki-mathjax>，中序序列是<anki-mathjax>\cdots b\cdots a\cdots</anki-mathjax>，则( )。<br>A. 结点a和结点b分别在某结点的左子树和右子树中<br>B. 结点b在结点a的右子树中<br>C. 结点b在结点a的左子树中<br>D. 结点a和结点b分别在某结点的两棵非空子树中]::(C)	1. 前序序列：a在b前 ⇒ a可能是b的祖先或左分支<br>2. 中序序列：b在a前 ⇒ b在a左子树中<br>3. <strong>结论</strong>：b位于a左子树（不一定是直接孩子）	155
[14. 一棵二叉树的先序遍历序列为1234567，它的中序遍历序列可能是( )。<br>A. 1234567<br>B. 2134567<br>C. 4135627<br>D. 1463572]::(B)	1. 前序首元素1为根，次元素2为右孩子<br>2. 中序序列特征：2在1前 ⇒ 2在左子树？但前序2在1后必为右子树<br>3. <strong>验证</strong>：B选项（2134567）满足右单支树结构	155
[15. 下列序列中，不能唯一地确定一棵二叉树的是( )。<br>A. 层次序列和中序序列<br>B. 先序序列和中序序列<br>C. 后序序列和中序序列<br>D. 先序序列和后序序列]::(D)	1. <strong>关键限制</strong>：先序/后序无法划分左右子树<br>2. 反例：先序AB + 后序BA 对应两种二叉树（左斜/右斜）<br>3. 其他选项组合均可唯一定位子树划分	155
[16. 若一棵二叉树的中序序列和后序序列相同，则( )。<br>A. 二叉树为空树或二叉树任一结点没有左子树<br>B. 二叉树为空树或二叉树任一结点没有右子树<br>C. 二叉树为空树或二叉树中每个结点的度为1<br>D. 二叉树为空树或二叉树为满二叉树]::(B)	1. <strong>遍历等价条件</strong>：中序（左根右） = 后序（左右根）<br>2. 必要条件：所有结点无右子树（"右"分支消失）<br>3. 特例：空树或仅含根结点的树自然满足	155
[17. 已知一棵二叉树的后序序列为DABEC，中序序列为DEBAC，则先序序列为（ ）。<br>A. ACBED<br>B. DECAB<br>C. DEABC<br>D. CEDBA]::(D)	1. 后序末位→根C，中序分割：左子树DEBA，右子树空<br>2. 左子树：后序DABE → 根E，中序DEBA → E左D，右BA<br>3. 右子树BA：后序AB → 根B，中序BA → B右A<br>4. 先序序列：C→E→D→B→A → <strong>CEDBA</strong>	157
[18. 已知一棵二叉树的先序遍历结果为ABCDEF，中序遍历结果为CBAEDF，则后序遍历的结果为（ ）。<br>A. CBEFDA<br>B. FEDCBA<br>C. CBEDFA<br>D. 不确定]::(A)	1. 先序首元素→根A，中序分割：左子树CB，右子树EDF<br>2. 左子树：先序BC → 根B，中序CB → B右C<br>3. 右子树：先序DEF → 根D，中序EDF → D左E，右F<br>4. 后序序列：C→B→E→F→D→A → <strong>CBEFDA</strong>	157
[19. 已知一棵二叉树的层次序列为ABCDEF，中序序列为BADCFE，则先序序列为（ ）。<br>A. ACBEDF<br>B. ABCDEF<br>C. BDFECA<br>D. FCEDBA]::(B)	1. 层次首元素→根A，中序分割：左子树B，右子树DCFE<br>2. 左子树B：无孩子<br>3. 右子树：层次C→D→E→F，中序DCFE → C左D，右FE<br>4. FE子树：中序FE → F左E？层次E→F ⇒ E父F？需重构<br>5. 最终先序：A→B→C→D→E→F → <strong>ABCDEF</strong>	157
[20. 某二叉树中的结点x，它在先序、中序、后序遍历序列中的编号分别为pre(x)，in(x)，post(x)（假设都是从1开始依次编号），a和b是树中任意两个结点，下列选项中错误的是（ ）。<br>A. a是b的后代且pre(a)<pre(b)<br>B. a是b的祖先且post(a)>post(b)<br>C. a是b的后代且in(a)<in(b)<br>D. a在b的左边且in(a)<in(b)]::(C)	1. <strong>遍历特性</strong>：中序遍历无法保证后代关系与顺序一致性<br>2. 反例：若b在a左子树，中序遍历先a后b（in(a)<in(b)）；但若b在a右子树则相反<br>3. 选项C错误：a是b后代时in(a)可能大于或小于in(b)	157
[21. 某二叉树采用二叉链表存储结构，若要删除该二叉链表中的所有结点，并释放它们占用的存储空间，则采用（ ）遍历方法最合适。<br>A. 中序<br>B. 层次<br>C. 后序<br>D. 先序]::(C)	1. <strong>内存安全</strong>：必须递归删除子树后才能删除根节点<br>2. 后序遍历顺序：左子树→右子树→根，天然符合删除逻辑<br>极. 避免内存泄漏：子树空间先释放再释放父结点	157
[22. 引入线索二叉树的目的是（ ）。<br>A. 加快查找结点的前驱或后继的速度<br>B. 为了能在二叉树中方便插入和删除<br>C. 为了能方便找到双亲<br>D. 使二叉树的遍历结果唯一]::(A)	1. <strong>核心目标</strong>：利用空指针域存储遍历顺序信息<br>2. 效率提升：避免递归遍历开销，直接定位前驱/后继结点<br>3. 应用场景：非递归遍历算法优化	157
[23. 线索二叉树是一种（ ）结构。<br>A. 逻辑<br>B. 逻辑和存储<br>C. 物理<br>D. 线性]::(C)	1. <strong>本质定义</strong>：添加了遍历信息的链式存储结构<br>2. 存储实现：在二叉链表基础上增加线索标志位<br>3. 与逻辑结构区分：二叉树是逻辑结构，线索化是存储优化	157
[24. n个结点的线索二叉树上含有的线索数为（ ）。<br>A. 2n<br>B. n-1<br>C. n+1<br>D. n]::(C)	1. <strong>指针分析</strong>：总指针域=2n，实际使用指针数=n-1（n结点树有n-1条边）<br>2. 线索数量：空闲指针域=2n-(n-1)=n+1<br>3. 数学公式：线索数=2n-(n-1)=n+1	157
[25. 判断线索二叉树中*p结点有右孩子结点的条件是（ ）。<br>A. p!=NULL<br>B. p->rchild!=NULL<br>C. p->rtag==0<br>D. p->rtag==1]::(C)	1. <strong>标志原理</strong>：rtag=0时右指针指向孩子，rtag=1时指向后继<br>2. 判断依据：仅当rtag==0时存在真实右孩子	157
[26. 一棵左子树为空的二叉树在先序线索化后，其中空的链域的个数是（ ）。<br>A. 不确定<br>B. 0个<br>C. 1个<br>D. 2个]::(D)	1. 结构特性：根结点无左孩子（左指针域必空且作前驱线索）<br>2. 先序最后结点：叶结点无后继（右指针域空且作后继线索）<br>3. 双重空链域：根左指针（线索）+ 最后结点右指针（线索）	157
[27. 在线索二叉树中，下列说法不正确的是（ ）。<br>A. 在中序线索树中，若某结点有右孩子，则其后继结点是它的右子树的最左下结点<br>B. 在中序线索树中，若某结点有左孩子，则其前驱结点是它的左子树的最右下结点<br>C. 线索二叉树是利用二叉树的n+1个空指针来存放结点的前驱和后继信息的<br>D. 每个结点通过线索都可以直接找到它的前驱和后继]::(D)	1. <strong>限制说明</strong>：先序线索树无法直接找前驱，后序线索树无法直接找后继<br>2. 反例证明：根节点的前驱（先序）无法仅靠线索定位	157
[28. 二叉树在线索化后，仍不能有效求解的问题是（ ）。<br>A. 先序线索二叉树中求先序后继<br>B. 中序线索二叉树中求中序后继<br>C. 中序线索二叉树中求中序前驱<br>D. 后序线索二叉树中求后序后继]::(D)	1. <strong>难点分析</strong>：后序后继需知双亲节点（右子树遍历完成后需返回上层）<br>2. 结构限制：二叉链表无父指针，无法直接获取后序后继	157
[29. 若X是二叉中序线索树中一个有左孩子的结点，且X不为根，则X的前驱为（ ）。<br>A. X的双亲<br>B. X的右子树中最左的结点<br>C. X的左子树中最右的结点<br>D. X的左子树中最右的叶结点]::(C)	1. <strong>中序特性</strong>：左子树最右侧结点是最后被访问的结点<br>2. 前驱定位规则：左子树的最右下结点（不一定是叶节点）	157
[30. 若X是后序线索二叉树中的叶结点，且X存在左兄弟Y，则X的右线索指向的是（ ）。<br>A. X的父结点<br>B. 以Y为根的子树的最左下结点<br>C. X的左兄弟结点Y<br>D. 以Y为根的子树的最右下结点]::(A)	1. <strong>后序规则</strong>：叶节点X的后继必为父节点（LRN顺序）<br>2. 线索功能：右指针线索化后存储后继信息	157
[31.（ ）的遍历仍需要栈的支持。<br>A. 前序线索树<br>B. 中序线索树<br>C. 后序线索树<br>D. 所有线索树]::(C)	1. <strong>核心原因</strong>：后序线索树无法通过线索直接返回父节点<br>2. 栈的用途：存储未处理完的子树信息以完成遍历	157
[32. 某二叉树的先序序列和后序序列正好相反，则该二叉树一定是（ ）。<br>A. 空或只有一个结点<br>B. 高度等于其结点数<br>C. 任意一个结点无左孩子<br>D. 任意一个结点无右孩子]::(B)	1. <strong>结构特征</strong>：每层仅有一个结点（左/右单支树）<br>2. 高度定义：树的高度等于从根到最远叶节点的路径长度	157
[33.【2009统考真题】给定二叉树如下图所示。设N代表二叉树的根，L代表根结点的左子树，R代表根结点的右子树。若遍历后的结点序列是3175624，则其遍历方式是（ ）。<br>A. LRN<br>B. NRL<br>C. RLN<br>D. RNL]::(D)	1. <strong>序列分析</strong>：3为最左节点，4为根节点，根节点出现在序列中部<br>2. <strong>遍历顺序</strong>：右子树→根→左子树（RNL）<br>3. 符号对应：R=右子树, N=根, L=左子树	157
[34.【2010统考真题】下列线索二叉树中（用虚线表示线索），符合后序线索树定义的是（ ）。]::(D)	1. <strong>后序序列</strong>：d→b→c→a<br>2. <strong>线索指向</strong>：d右线索→b, b左线索→d, c左线索→b右线索→a<br>3. 图D符合：d右线索指b, b左线索指d, c右线索指a	157
[35.【2011统考真题】一棵二叉树的前序遍历序列和后序遍历序列分别为1,2,3,4和4,3,2,1，该二叉树的中序遍历序列不会是（ ）。<br>A. 1,2,3,4<br>B. 2,3,4,1<br>C. 3,2,4,1<br>D. 4,3,2,1]::(C)	1. <strong>结构限制</strong>：前序/后序相反说明是单支树<br>2. <strong>中序特征</strong>：单支树中序呈单调递增/递减，选项C中3在2前不符合	157
[36.【2012统考真题】若一棵二叉树的前序遍历序列为a,e,b,d,c，后序遍历序列为b,c,d,e,a，则根结点的孩子结点（ ）。<br>A. 只有e<br>B. 有e,b<br>C. 有e,c<br>D. 无法确定]::(A)	1. <strong>根节点定位</strong>：a是根（前序首），e是最后被访问（后序倒数第二）<br>2. <strong>子树推断</strong>：bcd均在e的子树中，故根的直接孩子仅有e	157
[37.【2013统考真题】若X是后序线索二叉树中的叶结点，且X存在左兄弟Y，则X的右线索指向的是（ ）。<br>A. X的父结点<br>B. 以Y为根的子树的最左下结点<br>C. X的左兄弟结点Y<br>D. 以Y为根的子树的最右下结点]::(A)	1. <strong>后序规则</strong>：叶节点X的后继必为父节点（LRN顺序）<br>2. <strong>线索功能</strong>：右指针线索化后存储后继信息	157
[38.【2014统考真题】若对下图所示的二叉树进行中序线索化，则结点X的左、右线索指向的结点分别是（ ）。<br>A. e,c<br>B. e,a<br>C. d,c<br>D. b,a]::(D)	1. <strong>中序序列</strong>：d→e→h→x→a→c<br>2. <strong>线索定位</strong>：X前驱b（前序d-e-h），后继a（后序a-c）	157
[39.【2015统考真题】先序序列为a,b,c,d的不同二叉树的个数是（ ）。<br>A. 13<br>B. 14<br>C. 15<br>D. 16]::(B)	1. <strong>数学原理</strong>：前序序列相当于入栈序列，不同二叉树数=Catalan数<br>2. <strong>计算公式</strong>：<anki-mathjax>\frac{1}{n+1}C_{2n}^{n}=14</anki-mathjax>	158
[40.【2017统考真题】某二叉树的树形如下图所示，其后序序列为a,a,c,b,d,g,f，树中与结点a同层的结点是()。<br>A. c<br>B. d<br>C. f<br>D. g]::(B)	1. <strong>后序定位</strong>：a为第三层结点（后序第2个a）<br>2. <strong>层序遍历</strong>：同层结点为d（右子树部分）<br>3. 结点关系：a（左子树叶节点）与d（右子树叶节点）同层	158
[41.【2017统考真题】要使一棵非空二叉树的先序序列与中序序列相同，其所有非叶结点须满足的条件是()。<br>A. 只有左子树<br>B. 只有右子树<br>C. 结点的度均为1<br>D. 结点的度均为2]::(B)	1. <strong>遍历逻辑</strong>：先序"根左右"与中序"左根右"相同需左子树为空<br>2. <strong>必要条件</strong>：所有非叶结点仅含右子树	158
[42.【2022统考真题】若结点p与q在二叉树T的中序遍历序列中相邻，且p在q之前，则下列p与q的关系中，不可能的是()。<br>I. q是p的双亲<br>II. q是p的右孩子<br>III. q是p的右兄弟<br>IV. q是p的双亲的双亲<br>A. 仅I<br>B. 仅III<br>C. 仅II、III<br>D. 仅II、IV]::(B)	1. <strong>中序特性</strong>：p在q前说明p在q的左子树或p是q的左祖先<br>2. <strong>反例验证</strong>：q为p右兄弟时（同父），中序必先访问p再父节点最后q	158
[43.【2023统考真题】已知一棵二叉树的树形如下图所示，若其后序遍历序列为fdebeca，则其先(前)序遍历序列是()。<br>A. aedfbce<br>B. acebdf<br>C. cabefd<br>D. dfebac]::(A)	1. <strong>后序反推</strong>：a为根（末位），f为最左叶节点（首位）<br>2. <strong>子树划分</strong>：左子树后序fdeb → e为根，右子树后序c → c为右孩子<br>3. 前序遍历序列：<strong>a→e→d→f→b→c→e</strong>	158