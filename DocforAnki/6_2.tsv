[01. 下列关于图的存储结构的说法中，错误的是()。<br>A. 使用邻接矩阵存储一个图时，在不考虑压缩存储的情况下，所占用的存储空间大小只与图中的顶点数有关，与边数无关<br>B. 邻接表只用于有向图的存储，邻接矩阵适用于有向图和无向图<br>C. 若一个有向图的邻接矩阵的对角线以下的元素为0，则该图的拓扑序列必定存在<br>D. 存储无向图的邻接矩阵是对称的，所以只需存储邻接矩阵的下(或上)三角部分]::(B)	<strong>关键错误</strong>：邻接表<strong>也可用于无向图</strong>存储（每条边存储两次）。邻接矩阵存储空间复杂度恒为<anki-mathjax>O(n^{2})</anki-mathjax>，与边数无关（A正确）。	219
[02. 若图的邻接矩阵中主对角线上的元素皆为0，其余元素全为1，则该图一定()。<br>A. 是无向图<br>B. 是有向图<br>C. 是完全图<br>D. 不是带权图]::(C)	主对角线为0（无自环）+其他全为1 → <strong>任意两顶点间均有边相连</strong> → 必为完全图。	219
[03. 在含有n个顶点和e条边的无向图的邻接矩阵中，零元素的个数为()。<br>A. e<br>B. 2e<br>C. <anki-mathjax>n^{2}-e</anki-mathjax><br>D. <anki-mathjax>n^{2}-2e</anki-mathjax>]::(D)	无向图邻接矩阵中<strong>非零元素数=2e</strong>（对称存储） → 零元素数=<anki-mathjax>n^{2}-2e</anki-mathjax>。	219
[04. 带权有向图G用邻接矩阵存储，则<anki-mathjax>v_{i}</anki-mathjax>的入度等于邻接矩阵中()。<br>A. 第i行非<anki-mathjax>\infty</anki-mathjax>的元素个数<br>B. 第i列非<anki-mathjax>\infty</anki-mathjax>的元素个数<br>C. 第i行非<anki-mathjax>\infty</anki-mathjax>且非0的元素个数<br>D. 第i列非<anki-mathjax>\infty</anki-mathjax>且非0的元素个数]::(D)	入度由<strong>第i列</strong>决定：非<anki-mathjax>\infty</anki-mathjax>（有边）且非0（非自环）元素即入边。	219
[05. 一个有n个顶点的图用邻接矩阵A表示，若图为有向图，顶点<anki-mathjax>v_{i}</anki-mathjax>的入度是()；若图为无向图，顶点<anki-mathjax>v_{i}</anki-mathjax>的度是()。<br>A. <anki-mathjax>\sum_{i=1}^{n}A[i][j]</anki-mathjax><br>B. <anki-mathjax>\sum_{j=1}^{n}A[j][i]</anki-mathjax><br>C. <anki-mathjax>\sum_{i=1}^{n}A[j][i]</anki-mathjax><br>D. <anki-mathjax>\sum_{j=1}^{n}A[j][i]</anki-mathjax>或<anki-mathjax>\sum_{j=1}^{n}A[i][j]</anki-mathjax>]::(B,D)	<strong>有向图入度</strong>：对第i列求和（选项B）<br><strong>无向图度</strong>：对称矩阵，行/列求和均可（选项D）。	219
[06. 从邻接矩阵 A=\begin{bmatrix}0 &1&0\\1 &0&1\\0 &1&0\end{bmatrix} 可以看出，该图共有(①)个顶点;若是有向图，则该图共有(②)条弧;若是无向图，则共有(③)条边。<br>①A.9<br>B.3<br>C.6<br>D.1<br>E.以上答案均不正确<br>②A.5<br>B.4<br>C.3<br>D.2<br>E.以上答案均不正确<br>③A.5<br>B.4<br>C.3<br>D.2<br>E.以上答案均不正确]::(B,B,D)	①矩阵阶数=3 → 顶点数3<br>②有向图：<strong>非零元素数=弧数=5</strong><br>③无向图：对称矩阵 → 边数=非零元素数/2=2	219
[07. 以下关于图的存储结构的叙述中，正确的是()。<br>A. 一个图的邻接矩阵表示唯一，邻接表表示唯一<br>B. 一个图的邻接矩阵表示唯一，邻接表表示不唯一<br>C. 一个图的邻接矩阵表示不唯一，邻接表表示唯一<br>D. 一个图的邻接矩阵表示不唯一，邻接表表示不唯一]::(B)	<strong>邻接矩阵唯一</strong>（边位置固定）；邻接表<strong>不唯一</strong>（依赖建立顺序）。	219
[08. 矩阵A是有向图G的邻接矩阵，若矩阵<anki-mathjax>A^{2}</anki-mathjax>的某元素<anki-mathjax>a_{i,j}^{2}=3</anki-mathjax>，则说明()。<br>A. 从顶点i到j存在3条长度为2的路径<br>B. 从顶点i到j存在3条长度不超过2的路径<br>C. 从顶点i到j存在2条长度为3的路径<br>D. 从顶点i到j存在2条长度不超过3的路径]::(A)	<anki-mathjax>A^{k}[i][j]</anki-mathjax>直接表示<strong>长度为k的路径数</strong>。	220
[09. 用邻接表法存储图所用的空间大小()。<br>A. 与图的顶点数和边数有关<br>B. 只与图的边数有关<br>C. 只与图的顶点数有关<br>D. 与边数的平方有关]::(A)	空间复杂度<anki-mathjax>O(n+e)</anki-mathjax> → <strong>与顶点数n、边数e均相关</strong>。	220
[10. 若邻接表中有奇数个边表结点，则()。<br>A. 图中有奇数个结点<br>B. 图中有偶数个结点<br>C. 图为无向图<br>D. 图为有向图]::(D)	无向图边表结点数必为偶数（每条边存2次），<strong>奇数个边表结点 → 必为有向图</strong>。	220
[11. 在有向图的邻接表存储结构中，顶点v在边表中出现的次数是()。<br>A. 顶点v的度<br>B. 顶点v的出度<br>C. 顶点v的入度<br>D. 依附于顶点v的边数]::(C)	边表存储<strong>出边</strong>，顶点v在其他顶点的边表中出现 → 表示v的入度。	220
[12. n个顶点的无向图的邻接表最多有()个边表结点。<br>A.<anki-mathjax>n^{2}</anki-mathjax><br>B.<anki-mathjax>n(n-1)</anki-mathjax><br>C.<anki-mathjax>n(n+1)</anki-mathjax><br>D.<anki-mathjax>n(n-1)/2</anki-mathjax>]::(B)	最大边数<anki-mathjax>\frac{n(n-1)}{2}</anki-mathjax> → <strong>边表结点数=边数×2 = n(n-1)</anki-mathjax>。	220
[13. 设某无向图中有n个顶点和e条边，则建立该图的邻接表的时间复杂度是()。<br>A.<anki-mathjax>O(n+e)</anki-mathjax><br>B.<anki-mathjax>O(n^{2})</anki-mathjax><br>C.<anki-mathjax>O(ne)</anki-mathjax><br>D.<anki-mathjax>O(n^{3})</anki-mathjax>]::(A)	初始化顶点表<anki-mathjax>O(n)</anki-mathjax> + 插入e条边<anki-mathjax>O(e)</anki-mathjax>。	220
[14. 假设有n个顶点、e条边的有向图用邻接表表示，则删除与某个顶点v相关的所有边的时间复杂度为()。<br>A.<anki-mathjax>O(n)</anki-mathjax><br>B.<anki-mathjax>O(e)</anki-mathjax><br>C.<anki-mathjax>O(n+e)</anki-mathjax><br>D.<anki-mathjax>O(ne)</anki-mathjax>]::(C)	删除出边：遍历v的边表（<anki-mathjax>O(\text{出度}) \leq O(n)</anki-mathjax>）<br>删除入边：扫描全部边表（<anki-mathjax>O(n+e)</anki-mathjax>）	220
[15. 对邻接表的叙述中，()是正确的。<br>A. 无向图的邻接表中，第i个顶点的度为第i个链表中结点数的两倍<br>B. 邻接表比邻接矩阵的操作更简便<br>C. 邻接矩阵比邻接表的操作更简便<br>D. 求有向图结点的度，必须遍历整个邻接表]::(D)	A错：无向图度=第i链表结点数<br>B/C错：操作优劣因场景而异<br>D正确：计算<strong>入度需全局扫描边表</strong>。	220
[16. 邻接多重表是()的存储结构。<br>A. 无向图<br>B. 有向图<br>C. 无向图和有向图<br>D. 都不是]::(A)	邻接多重表专门优化<strong>无向图</strong>的边存储（避免重复）。	220
[17. 十字链表是()的存储结构。<br>A. 无向图<br>B. 有向图<br>C. 无向图和有向图<br>D. 都不是]::(B)	十字链表设计用于高效存储<strong>有向图</strong>（区分入/出边）。	220
[18.【2013统考真题】设图的邻接矩阵A如下所示，各顶点的度依次是()。<br><anki-mathjax>A=\begin{bmatrix}0&1&0&1\\0&0&1&1\\0&1&0&0\\1&0&0&0\end{bmatrix}</anki-mathjax><br>A.1,2,1,2<br>B.2,2,1,1<br>C.3,4,2,3<br>D.4,4,2,2]::(C)	有向图顶点度=出度+入度：<br>• v1: 出度2(行1:1,1) + 入度1(列1:1) = 3<br>• v2: 出度2(行2:1,1) + 入度2(列2:1,1) = 4<br>• v3: 出度1(行3:1) + 入度1(列3:1) = 2<br>• v4: 出度2(行4:1,1?) 但第4行实际有<strong>1个非0元素</strong>（需重新计算矩阵）<br>修正：v4出度=1(行4:1) + 入度2(列4:1,1) → 度=3 → 正确序列为3,4,2,3	220
[19.【2023统考真题】已知有向图G采用邻接矩阵存储，类型定义如下：<br>typedef struct{<br>int numVertices,numEdges;<br>char VerticesList[MAXV];<br>int Edge[MAXV][MAXV];<br>}MGraph;<br>将图中出度大于入度的顶点称为K顶点。请设计算法int printVertices(MGraph G)，输出G中所有K顶点，并返回K顶点个数。]::(算法题无字母答案)	<strong>算法设计</strong>：<br>1. 遍历邻接矩阵，计算各顶点出度（行非0/∞元素数）和入度（列非0/∞元素数）<br>2. 若出度>入度，输出顶点名并计数<br>3. 返回K顶点个数<br><strong>时间复杂度</strong>：<anki-mathjax>O(n^{2})</anki-mathjax>（n为顶点数）	222