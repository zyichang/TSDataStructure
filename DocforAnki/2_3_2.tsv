01.在带头结点的单链表L中，删除所有值为x的结点，并释放其空间，假设值为x的结点不唯一，试编写算法以实现上述操作。	• 算法思想：从链表<strong>头结点</strong>开始遍历链表，找到值为x的结点，将其删除并释放空间，继续遍历直到链表末尾。	43
02.试编写在带头结点的单链表L中删除一个最小值结点的高效算法（假设该结点唯一）。	• 算法思想：用两个指针p和q遍历链表，p用于查找<strong>最小值结点</strong>，q用于记录p的<strong>前驱结点</strong>，找到后删除最小值结点。	43
03.设计一个算法将带头结点的单链表就地逆置，所谓"就地逆置"是指辅助空间复杂度为O(1)。	• 算法思想：将链表逆置可以通过改变<strong>指针方向</strong>实现，从第二个结点开始，依次将结点的next指向前驱结点，最后更新头结点。	43
04.编写算法将一个整数插到由尾指针指向的尾结点之后的位置上。	• 算法思想：找到链表的<strong>尾结点</strong>，创建新结点插入到尾结点之后。	43
05.给定两个单链表，试编写算法判断两个链表是否相交（即是否存在公共结点，但不允许遍历链表遍历到表尾之外的结点）。	• 算法思想：利用<strong>快慢指针法</strong>，快指针每次走两步，慢指针每次走一步，若快慢指针相遇则两链表相交。	43
06.设A=($a_1,b_1,a_2,b_2,\cdots,a_n,b_n$)为线性表，采用带头结点的单链表存放，设计一个就地算法将其拆分成两个单链表，使得A表中含有所有的奇数序号元素，而B表中含有所有的偶数序号元素，且保持原来的相对次序。	• 算法思想：用一个指针遍历链表，根据序号的<strong>奇偶性</strong>将结点分别插入到两个新链表中。	43
07.在一个递增有序的单链表中，存在重复的元素。设计一个算法删除重复的元素，例如，将(7,10,10,21,30,42,42,42,51,70)变为(7,10,21,30,42,51,70)。	• 算法思想：用两个指针p和q遍历链表，p用于查找<strong>重复结点</strong>，q用于记录前驱结点，删除重复结点。	43
08.设A和B是两个带头结点的单链表，其中元素递增有序。设计一个算法从A和B中的公共元素产生单链表C，要求不破坏A、B结点且C中元素无重复。	• 算法思想：用两个指针分别遍历A和B链表，比较结点值，将相同的结点插入到C链表中，且不<strong>重复插入</strong>。	43
09.已知两个链表A和B分别表示两个集合，其元素递增排列。编制函数，求A与B的交集，并存放于A链表中。	• 算法思想：用两个指针分别遍历A和B链表，比较结点值，将相同的结点依次插入到A链表中。	43
10.两个整数序列A = $a_1,a_2,\cdots,a_m$和B = $b_1,b_2,\cdots,b_n$已经存入两个单链表中，设计一个算法，判断序列B是否是序列A的连续子序列。	• 算法思想：用两个指针分别遍历A和B链表，判断B链表的所有结点是否在A链表中<strong>连续出现</strong>。	43
11.设计一个算法用于判断带头结点的循环链表是否对称。	• 算法思想：用两个指针从<strong>循环链表</strong>头开始遍历，根据结点的对称关系判断是否对称。	43
12.有两个循环链表，链表头指针分别为h1和h2。编写一个函数将链表h2连接到链表h1之后，要求连接后的链表仍保持循环链表形式。	• 算法思想：找到h1链表的<strong>尾结点</strong>，将其next指向h2链表的头结点，再将h2链表的尾结点的next指向h1链表的头结点。	43
13.假设有一个带头结点的非循环双向链表L，每个结点中除有pre、data和next域外，还有一个访问频度域freq，其值初始时都为0，每当在链表中进行一次Locate(L,x)运算，使查找成功结点的freq域的值增1，并使此结点的位置移至双向链表的表头，试编写符合上述要求的Locate(L,x)函数，返回找到结点的地址，类型是结点指针。	• 算法思想：遍历双向链表，查找值为x的结点，若找到则将该结点的<strong>freq值加1</strong>，然后调整结点位置：将其从当前位置移除，插入到<strong>头结点之后</strong>的位置，更新相关指针。	43
14.设将n(n>1)个整数存放到不带头结点的单链表L中，设计算法将L中保存的序列循环右移k(0<k<n)个位置。要求：1)给出算法的基本设计思想 2)采用C/C++描述算法 3)说明时间/空间复杂度。	算法思想：1) 计算实际右移量<anki-mathjax>k'= k \% n</anki-mathjax> 2) 找到<strong>新尾结点</strong>(第<anki-mathjax>n - k'</anki-mathjax>个结点) 3) 链表首尾连接形成环，断开新尾结点与原头结点的链接。时间复杂度<anki-mathjax>O(n)</anki-mathjax>，空间复杂度<anki-mathjax>O(1)</anki-mathjax>。	44
15.单链表有环，是指单链表的最后一个结点的指针指向了链表中的某个结点。试编写算法判断单链表是否存在环。要求：1)给出算法的基本设计思想 2)采用C/C++描述算法 3)说明时间/空间复杂度。	算法思想：使用<strong>快慢指针法</strong>，快指针每次走两步，慢指针走一步。若两指针相遇则存在环，若快指针到达表尾则无环。时间复杂度<anki-mathjax>O(n)</anki-mathjax>，空间复杂度<anki-mathjax>O(1)</anki-mathjax>。	44
16.设有一个长度n(n为偶数)的不带头结点的单链表，且结点值都大于0，设计算法求这个单链表的最大孪生和。孪生和定义为一个结点值与其孪生结点值之和。要求：1)给出算法的基本设计思想 2)采用C/C++描述算法 3)说明时间/空间复杂度。	算法思想：1) 使用<strong>快慢指针</strong>找到链表中点 2) <strong>反转后半部分链表</strong> 3) 用双指针分别遍历前/后半部分，计算孪生和并维护最大值。时间复杂度<anki-mathjax>O(n)</anki-mathjax>，空间复杂度<anki-mathjax>O(1)</anki-mathjax>。	44
17.【2009统考真题】已知一个带有表头结点的单链表，在不改变链表的前提下，设计高效算法查找链表中倒数第k个位置上的结点(k为正整数)。要求：1)描述算法的基本设计思想 2)描述实现步骤 3)用C/C++实现。	算法思想：1) 使用两个指针<strong>p1/p2</strong>，p1先移动k步 2) 两指针同步移动直至p1到表尾 3) p2即指向倒数第k结点。时间复杂度<anki-mathjax>O(n)</anki-mathjax>，空间复杂度<anki-mathjax>O(1)</anki-mathjax>。	44
18.【2012统考真题】假定采用带头结点的单链表保存单词，当两个单词有相同的后缀时，可共享相同的后缀存储空间。设计时间上尽可能高效的算法，找出由str1和str2所指向两个链表共同后缀的起始位置。要求：1)给出算法的基本设计思想 2)用C/C++描述算法 3)说明时间复杂度。	算法思想：1) 计算两链表长度差d 2) 长链表指针先移动d步 3) <strong>双指针同步移动</strong>直至指向相同结点。时间复杂度<anki-mathjax>O(m+n)</anki-mathjax>（m/n为链表长度）。	44
19.【2015统考真题】用单链表保存m个整数，结点的结构为[data][link]，且$ \mid data\mid\leq n(n $为正整数)。设计高效算法，删除链表中绝对值相等的结点(仅保留首次出现的结点)。要求：1)基本设计思想 2)结点数据类型定义 3)算法实现 4)复杂度分析。	算法思想：使用<strong>哈希表</strong>记录绝对值出现情况。顺序遍历链表：当绝对值首次出现时加入哈希表；重复出现时删除该结点。时间复杂度<anki-mathjax>O(m)</anki-mathjax>，空间复杂度<anki-mathjax>O(n)</anki-mathjax>。	44
20.【2019统考真题】设线性表$L=(a_1,a_2,a_3,\cdots,a_{n-1},a_n)$采用带头结点的单链表保存。设计空间复杂度为<anki-mathjax>O(1)</anki-mathjax>的算法，重新排列各结点得到$L'=(a_1,a_n,a_2,a_{n-1},\cdots)$。要求：1)基本设计思想 2)算法实现 3)时间复杂度。	算法思想：1) <strong>快慢指针</strong>找中点分割链表 2) <strong>反转后半部分链表</strong> 3) <strong>交叉合并</strong>前后两部分。时间复杂度<anki-mathjax>O(n)</anki-mathjax>，空间复杂度<anki-mathjax>O(1)</anki-mathjax>。	45