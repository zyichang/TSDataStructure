[01.顺序查找适合于存储结构为（  ）的线性表。<br>A.顺序存储结构或链式存储结构<br>B.散列存储结构<br>C.索引存储结构<br>D.压缩存储结构]::(A)	顺序查找不要求查找表具有随机存取的特性，适合顺序存储或链式存储结构	283
[02.由n个数据元素组成的两个表：一个递增有序，一个无序，采用顺序查找算法，对有序表从头开始查找，发现当前元素已不小于待查元素时，停止查找，确定查找不成功，已知查找任意一个元素的概率是相同的，则在两种表中成功查找（  ）。<br>A.平均时间后者小<br>B.平均时间两者相同<br>C.平均时间前者小<br>D.无法确定]::(B)	每个元素查找成功的比较次数只与其位置有关（与是否有序无关），平均查找长度相同	283
[03.对长度为n的有序单链表，若查找每个元素的概率相等，则顺序查找表中任意一个元素的查找成功的平均查找长度为（  ）。<br>A.n/2<br>B.(n+1)/2<br>C.(n-1)/2<br>D.n/4]::(B)	有序单链表顺序查找的平均查找长度与无序表相同，均为<anki-mathjax> \frac{n+1}{2} </anki-mathjax>	283
[04.对长度为3的顺序表进行查找，若查找第一个元素的概率为1/2，查找第二个元素的概率为1/3，查找第三个元素的概率为1/6，则查找任意一个元素的平均查找长度为（  ）。<br>A.5/3<br>B.2<br>C.7/3<br>D.4/3]::(A)	ASL=1×<anki-mathjax> \frac{1}{2} </anki-mathjax> + 2×<anki-mathjax> \frac{1}{3} </anki-mathjax> + 3×<anki-mathjax> \frac{1}{6} </anki-mathjax> = <anki-mathjax> \frac{5}{3} </anki-mathjax>	283
[05.下列关于二分查找的叙述中，正确的是（  ）。<br>A.表必须有序，表可以顺序方式存储，也可以链表方式存储<br>B.表必须有序且表中数据必须是整型、实型或字符型<br>C.表必须有序，而且只能从小到大排列<br>D.表必须有序，且表只能以顺序方式存储]::(D)	二分查找要求表有序且必须是顺序存储结构（下标定位中间元素）	283
[06.在一个顺序存储的有序线性表上查找一个数据时，既可以采用折半查找，也可以采用顺序查找，但前者比后者的查找速度（  ）。<br>A.必然快<br>B.取决于表是递增还是递减<br>C.在大部分情况下要快<br>D.必然不快]::(C)	在大部分情况下更快（但查找首元素时顺序查找更快）	283
[07.折半查找过程所对应的判定树是一棵（  ）。<br>A.最小生成树<br>B.平衡二叉树<br>C.完全二叉树<br>D.满二叉树]::(B)	折半查找对应的判定树总是平衡二叉树（左右子树高度差≤1）	283
[08.折半查找和二叉排序树的时间性能（  ）。<br>A.相同<br>B.有时不相同<br>C.完全不同<br>D.无法比较]::(B)	折半查找最坏O(logn)，二叉排序树最坏O(n)（形成单支树时）	283
[09.在有11个元素的有序表A[1,2,…,11]中进行折半查找（[low+high)/2]），查找元素A[11]时，被比较的元素下标依次是（  ）。<br>A.6,8,10,11<br>B.6,9,10,11<br>C.6,7,9,11<br>D.6,8,9,11]::(A)	路径：mid=6→8→10→11（按向下取整规则）	283
[10.已知有序表(13,18,24,35,47,50,62,83,90,115,134)，当二分查找值为90的元素时，查找成功的元素比较次数为（  ）。<br>A.1<br>B.2<br>C.4<br>D.6]::(B)	比较序列：第1个62（下标6）→ 第2个90（下标9）	283
[11.若有序表的关键字序列为{b,c,d,e,f,g,q,r,s,t}，则在二分查找关键字b的过程中，进行比较的关键字依次为（  ）。<br>A.f,c,b<br>B.f,d,b<br>C.g,c,b<br>D.g,d,b]::(A)	比较序列：第一个f（下标5）→ c（下标2）→ b（下标1）	283
[12.对表长为n的有序表进行折半查找，其判定树的高度为（  ）。<br>A.<anki-mathjax> \lceil\log_{2}(n+1)\rceil </anki-mathjax><br>B.<anki-mathjax> \lfloor\log_{2}(n+1)\rfloor-1 </anki-mathjax><br>C.<anki-mathjax> \lceil\log_{2}n\rceil </anki-mathjax><br>D.<anki-mathjax> \lfloor\log_{2}n\rfloor-1 </anki-mathjax>]::(A)	高度公式<anki-mathjax> h=\lceil\log_{2}(n+1)\rceil </anki-mathjax>	283
[13.已知一个长度为16的顺序表，其元素按关键字有序排列，若采用折半查找算法查找一个不存在的元素，则比较的次数至少是（  ），至多是（  ）。<br>A.4<br>B.5<br>C.6<br>D.7]::(A,B)	最坏情况比较<anki-mathjax> \lceil\log_{2}17\rceil=5 </anki-mathjax>次	283
[14.具有12个关键字的有序表中，对每个关键字的查找概率相同，折半查找算法查找成功的平均查找长度为（  ），折半查找查找失败的平均查找长度为（  ）。<br>A.37/12<br>B.35/12<br>C.39/13<br>D.49/13]::(A,D)	成功ASL=(1+2×2+3×4+4×5)/12=37/12<br>失败ASL=(3×3+4×10)/13	283
[15.下列关于查找的说法中，正确的是（  ）。<br>A.若数据元素保持有序，则查找时就可以采用折半查找法<br>B.折半查找与二叉查找树的时间性能在最坏情况下是相同的<br>C.折半查找法的平均查找长度一定小于顺序查找法<br>D.折半查找法查找一个元素大约需要O(log2n)次关键字比较]::(D)	折半查找时间复杂度O(logn)，其他选项均有反例	283
[16.采用分块查找时，数据的组织方式为（  ）。<br>A.数据分成若干块，每块内数据有序<br>B.数据分成若干块，每块内数据不必有序，但块间必须有序，每块内最大（或最小）的数据组成索引块<br>C.数据分成若干块，每块内数据有序，每块内最大（或最小）的数据组成索引块<br>D.数据分成若干块，每块（除最后一块外）中数据个数需相同]::(B)	分块查找要求块间有序（索引表有序）、块内无序	283
[17.对有2500个记录的索引顺序表(分块表)进行查找，最理想的块长为（  ）。<br>A.50<br>B.125<br>C.500<br>D.<anki-mathjax> \lceil\log_{2}2500\rceil </anki-mathjax>]::(A)	最优块长<anki-mathjax> \sqrt{n}=50 </anki-mathjax>	285
[18.设顺序存储的某线性表共有123个元素，按分块查找的要求等分为3块。若对索引表采用顺序查找法来确定子块，且在确定的子块中也采用顺序查找法，则在等概率情况下，分块查找成功的平均查找长度为（  ）。<br>A.21<br>B.23<br>C.41<br>D.62]::(B)	ASL=索引ASL( <anki-mathjax> \frac{b+1}{2} </anki-mathjax> )+块内ASL( <anki-mathjax> \frac{s+1}{2} </anki-mathjax> )= <anki-mathjax> \frac{4}{2} </anki-mathjax>+<anki-mathjax> \frac{42}{2} </anki-mathjax>=23	285
[19.为提高查找效率，对有65025个元素的有序顺序表建立索引顺序结构，在最好情况下查找到表中已有元素最多需要执行（  ）次关键字比较。<br>A.10<br>B.14<br>C.16<br>D.21]::(C)	最优分块<anki-mathjax> \sqrt{65025}=255 </anki-mathjax>，索引和块内均折半查找：2×<anki-mathjax> \lceil\log_2 256\rceil </anki-mathjax>=16	285
[20.[2010统考真题]已知一个长度为16的顺序表L，其元素按关键字有序排列，若采用折半查找法查找一个L中不存在的元素，则关键字的比较次数最多是（  ）。<br>A.4<br>B.5<br>C.6<br>D.7]::(B)	最大比较次数=树高=<anki-mathjax> \lceil\log_2 17\rceil=5 </anki-mathjax>	285
[21.[2015统考真题]下列选项中，不能构成折半查找中关键字比较序列的是（  ）。<br>A.500,200,450,180<br>B.500,450,200,180<br>C.180,500,200,450<br>D.180,200,500,450]::(A)	选项A比较序列不符合折半查找的递归规则	285
[22.[2016统考真题]在有n(n>1000)个元素的升序数组A中查找关键字x。查找算法的伪代码如下所示。<br>k=0;<br>while(k<n且A[k]<x) k=k+3;<br>if(k<n且A[k]==x)查找成功;<br>else if(k-2<n且A[k-2]==x)查找成功;<br>else if(k-2<n且A[k-2]==x)查找成功;<br>else 查找失败;<br>本算法与折半查找算法相比，有可能具有更少比较次数的情形是（  ）。<br>A.当x不在数组中<br>B.当x接近数组开头处<br>C.当x接近数组结尾处<br>D.当x位于数组中间位置]::(B)	跳跃式查找在x靠近开头时比较次数较少	285
[23.[2017统考真题]下列二叉树中，可能成为折半查找判定树(不含外部结点)的是（  ）。<br>A.<br>B.<br>C.<br>D.]::(A)	折半查找判定树必须满足平衡二叉树的特性	285
[24.[2023统考真题]对含600个元素的有序顺序表进行折半查找，关键字间的比较次数最多是（  ）。<br>A.9<br>B.10<br>C.30<br>D.300]::(B)	最大比较次数=<anki-mathjax> \lceil\log_2 601\rceil=10 </anki-mathjax>	285