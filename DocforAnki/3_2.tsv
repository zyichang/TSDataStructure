[01. 栈和队列的主要区别在于（ ）。<br>A. 它们的逻辑结构不一样<br>B. 它们的存储结构不一样<br>C. 所包含的元素不一样<br>D. 插入、删除操作的限定不一样]::(D)	1. 栈和队列的<strong>逻辑结构相同</strong>（均为线性结构）<br>2. 存储结构均可为顺序或链式<br>3. 本质区别在于<strong>操作限定</strong>：栈（LIFO）仅允许栈顶操作，队列（FIFO）允许两端操作	84
[02. 队列的“先进先出”特性是指（ ）。<br>I. 最后插入队列中的元素总是最后被删除<br>II. 当同时进行插入、删除操作时，总是插入操作优先<br>III. 每当有删除操作时，总要先做一次插入操作<br>IV. 每次从队列中删除的总是最早插入的元素]::(B)	1. <strong>I正确</strong>：符合FIFO原则<br>2. <strong>IV正确</strong>：删除操作总是针对最早插入的元素<br>3. II错误：操作无优先顺序<br>4. III错误：删除操作无需先插入	84
[03. 允许对队列进行的操作有（ ）。<br>A. 对队列中的元素排序<br>B. 取出最近进队的元素<br>C. 在队头元素之前插入元素<br>D. 删除队头元素]::(D)	1. 队列基本操作：<br>   • <strong>队尾插入</strong>（入队）<br>   • <strong>队头删除</strong>（出队）<br>2. 禁止：插队（C）、随机取元素（B）、排序（A）	84
[04. 一个队列的入队顺序是1, 2, 3, 4，则出队的输出顺序是（ ）。<br>A. 4, 3, 2, 1<br>B. 1, 2, 3, 4<br>C. 1, 4, 3, 2<br>D. 3, 2, 4, 1]::(B)	1. 队列<strong>严格遵循FIFO</strong>（先进先出）<br>2. 入队顺序 = 出队顺序 → 结果为1,2,3,4	84
[05. 循环队列存储在数组A[0..n]中，入队时的操作为（ ）。<br>A. rear=rear+1<br>B. rear=(rear+1) mod (n-1)<br>C. rear=(rear+1) mod n<br>D. rear=(rear+1) mod (n+1)]::(D)	1. 数组下标范围：0~n → 长度<anki-mathjax>n+1</anki-mathjax><br>2. 循环队列入队：<code>rear=(rear+1) mod length</code> → 取模<anki-mathjax>n+1</anki-mathjax>	84
[06. 设有一个循环队列的存储空间为数组A[21]，front指向队头元素的前一个位置，rear指向队尾元素，假设当前front和rear的值分别为8和3，则该队列的长度为（ ）。<br>A. 5<br>B. 6<br>C. 16<br>D. 17]::(C)	1. 长度公式：<anki-mathjax>(rear - front + maxsize) \\% maxsize</anki-mathjax><br>2. 代入：<anki-mathjax>(3 - 8 + 21) \\% 21 = 16</anki-mathjax><br>3. <strong>maxsize=21</strong>（数组长度）	84
[07. 若用数组A[0..5]实现循环队列，且当前front和rear的值分别为5和1，当从队列中删除一个元素，再加入两个元素后，rear和front的值分别为（ ）。<br>A. 3和6<br>B. 3和0<br>C. 5和0<br>D. 5和1]::(B)	1. 删除元素：<code>front=(front+1) mod 6=(5+1) mod 6=0</code><br>2. 加入元素1：<code>rear=(1+1) mod 6=2</code><br>3. 加入元素2：<code>rear=(2+1) mod 6=3</code><br>4. 最终状态：front=0，rear=3	84
[08. 假设用数组Q[MaxSize]实现循环队列，队首指针front指向队首元素的前一位置，队尾指针rear指向队尾元素，则判断该队列为空的条件是（ ）。<br>A. (Q.rear+1)%MaxSize==(Q.front+1)%MaxSize<br>B. (Q.rear+1)%MaxSize==Q.front<br>C. (Q.rear)%MaxSize==Q.front<br>D. Q.rear==Q.front]::(D)	1. <strong>初始化时</strong>：front=rear<br>2. 空队列条件：<strong>无有效元素</strong> → front始终等于rear	84
[09. 假设循环队列Q[MaxSize]的队头指针为front，队尾指针为rear，队列的最大容量为MaxSize，此外，该队列再没有其他数据成员，则判断该队列已满条件是（ ）。<br>A. Q.front==Q.rear<br>B. Q.front+Q.rear>=MaxSize<br>C. Q.front==(Q.rear+1)%MaxSize<br>D. Q.rear==(Q.front+1)%MaxSize]::(C)	1. 采用<strong>牺牲一个存储单元</strong>方案<br>2. 队满条件：队头指针在队尾指针下一位置 → <code>front==(rear+1)%MaxSize</code>	84
[10. 假设用A[0..n]实现循环队列，front、rear分别指向队首元素的前一个位置和队尾元素。若用(rear+1)%(n+1)==front作为队满标志，则（ ）。<br>A. 可用front==rear作为队空标志<br>B. 队列中最多可有n+1个元素<br>C. 可用front>rear作为队空标志<br>D. 可用(front+1)%(n+1)==rear作为队空标志]::(A)	1. <strong>牺牲一个单元</strong>：实际容量<anki-mathjax>n</anki-mathjax><br>2. 队空条件与牺牲方案一致：<code>front==rear</code>	84
[11. 与顺序队列相比，链式队列（ ）。<br>A. 优点是队列的长度不受限制<br>B. 优点是进队和出队时间效率更高<br>C. 缺点是不能进行顺序访问<br>D. 缺点是不能根据队首指针和队尾指针计算队列的长度]::(D)	1. <strong>共同点</strong>：进/出队<anki-mathjax>O(1)</anki-mathjax>，均支持顺序访问<br>2. 链式缺点：<strong>无法直接计算长度</strong>（需遍历）<br>3. 长度限制取决于内存	88
[12. 最适合用作队列的链表是（ ）。<br>A. 带队首指针和队尾指针的循环单链表<br>B. 带队首指针和队尾指针的非循环单链表<br>C. 只带队首指针的非循环单链表<br>D. 只带队首指针的循环单链表]::(B)	1. 非循环单链表：<br>   • <strong>队首指针</strong>支持<anki-mathjax>O(1)</anki-mathjax>删除<br>   • <strong>队尾指针</strong>支持<anki-mathjax>O(1)</anki-mathjax>插入<br>2. 无需循环（操作更简单）	88
[13. 最不适合用作链式队列的链表是（ ）。<br>A. 只带队首指针的非循环双链表<br>B. 只带队首指针的循环双链表<br>C. 只带队尾指针的循环双链表<br>D. 只带队尾指针的循环单链表]::(A)	1. 入队需<strong>查找队尾</strong>：时间复杂度<anki-mathjax>O(n)</anki-mathjax><br>2. 其他选项均能<anki-mathjax>O(1)</anki-mathjax>完成入/出队	88
[14. 在用单链表实现队列时，队头设在链表的（ ）位置。<br>A. 链头<br>B. 链尾<br>C. 链中<br>D. 以上都可以]::(A)	1. <strong>删除操作在表头</strong>：时间复杂度<anki-mathjax>O(1)</anki-mathjax><br>2. 插入操作在表尾（配合尾指针）	88
[15. 用链式存储方式的队列进行删除操作时需要（ ）。<br>A. 仅修改头指针<br>B. 仅修改尾指针<br>C. 头尾指针都要修改<br>D. 头尾指针可能都要修改]::(D)	1. <strong>一般情况</strong>：仅修改头指针<br>2. <strong>删除最后一个元素</strong>时：需置空尾指针 → 需修改头尾指针	88
[16. 在一个链队列中，假设队头指针为front，队尾指针为rear，x所指向的元素需要入队，则需要执行的操作为（ ）。<br>A. front=x，front=front->next<br>B. x->next=front->next，front=x<br>C. rear->next=x，rear=x<br>D. rear->next=x，x->next=NULL，rear=x]::(D)	入队标准操作：<br>1. <code>rear->next = x</code>（链接新节点）<br>2. <code>x->next = NULL</code>（新节点置为表尾）<br>3. <code>rear = x</code>（更新尾指针）	88
[17. 假设循环单链表表示的队列长度为n，队头固定在链表尾，若只设头指针，则进队操作的时间复杂度为（ ）。<br>A. <anki-mathjax>O(n)</anki-mathjax><br>B. <anki-mathjax>O(1)</anki-mathjax><br>C. <anki-mathjax>O(n^{2})</anki-mathjax><br>D. <anki-mathjax>O(n\log n)</anki-mathjax>]::(A)	1. 进队在<strong>表头插入</strong><br>2. 队头在表尾 → <strong>需遍历找队尾</strong>：<anki-mathjax>O(n)</anki-mathjax>	88
[18. 若输入序列为1,2,3,4,5，利用两个队列进行出入队操作，不可能得到的输出序列是（ ）。<br>A. 1,2,3,4,5<br>B. 5,1,2,3,4<br>C. 1,3,2,4,5<br>D. 1,3,5,2,4]::(B)	1. B序列：5首出时，1,2,3,4应在另一队列<br>2. 5出队后，1,2,3,4出队顺序<strong>必须保持原序</strong> → 只能是5,1,2,3,4（无法得5,1）	88
[19. 若以1,2,3,4作为双端队列的输入序列，则既不能由输入受限的双端队列得到，又不能由输出受限的双端队列得到的输出序列是（ ）。<br>A. 1,2,3,4<br>B. 4,1,3,2<br>C. 4,2,3,1<br>D. 4,2,1,3]::(C)	• <strong>排除法</strong>：<br>  - A可通过普通队列得到<br>  - B可由输入受限双端队列获得（右端受限）<br>  - D可由输出受限双端队列获得（左端输出受限）<br>• C序列要求4首出后2立即出，但2在1后入队 → 违反双端队列操作规则	86
[20. 【2010统考真题】某队列允许在其两端进行入队操作，但仅允许在一端进行出队操作。若元素a,b,c,d,e依次入此队列后再进行出队操作，则不可能得到的出队序列是（ ）。<br>A. b,a,c,d,e<br>B. d,b,a,c,e<br>C. d,b,c,a,e<br>D. e,c,b,a,d]::(C)	• <strong>本质是输出受限双端队列</strong><br>• C序列要求：d首出时a,b,c已入队，b必须在c前出队 → 序列d后接b,c矛盾<br>• <strong>核心规则</strong>：相邻入队的元素在输出序列中必相邻	86
[21. 【2011统考真题】已知循环队列存储在一维数组A[0...n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列为空，且要求第一个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是（ ）。<br>A. 0,0<br>B. 0,n-1<br>C. n-1,0<br>D. n-1,n-1]::(B)	1. 第一个元素入<code>A[0]</code>要求<code>rear=0</code><br>2. 元素入队后：<code>rear=(rear+1)%n</code><br>3. 初始空队列：<code>front</code>应与<code>rear</code>相等 → 需<code>front=0, rear=n-1</code>（加1后模n得0）	86
[22. 【2014统考真题】循环队列放在一维数组A[0...M-1]中，end1指向队头元素，end2指向队尾元素的后一个位置。假设队列两端均可进行入队和出队操作，队列中最多能容纳M-1个元素。初始时为空。下列判断队空和队满的条件中，正确的是（ ）。<br>A. 队空：end1==end2; 队满：end1==(end2+1)mod M<br>B. 队空：end1==end2; 队满：end2==(end1+1)mod M<br>C. 队空：end2==(end1+1)mod M; 队满：end1==(end2+1)mod M<br>D. 队空：end1==(end2+1)mod M; 队满：end2==(end1+1)mod M]::(A)	• <strong>队空条件</strong>：指针重合（end1==end2）<br>• <strong>队满条件</strong>：end1与end2相距1个单元 → <code>end1=(end2+1) mod M</code><br>• 注：实际容量<anki-mathjax>M-1</anki-mathjax>	86
[23. 【2018统考真题】现有队列Q与栈S，初始时Q中的元素依次是1,2,3,4,5,6（1在队头），S为空。若仅允许下列3种操作：①出队并输出出队元素；②出队并将出队元素入栈；③出栈并输出出栈元素，则不能得到的输出序列是（ ）。<br>A. 1,2,5,6,4,3<br>B. 2,3,4,5,6,1<br>C. 3,4,5,6,1,2<br>D. 6,5,4,3,2,1]::(C)	• <strong>C序列问题</strong>：输出3后需输出4,5,6<br>• 但1,2<strong>必须</strong>在输出3前入栈 → 2应在1前出栈（实际序列1在2前输出）<br>• 其他选项均可通过操作组合实现	86
[24. 【2021统考真题】初始为空的队列Q的一端仅能进行入队操作，另外一端既能进行入队操作又能进行出队操作。若Q的入队序列是1,2,3,4,5，则不能得到的出队序列是（ ）。<br>A. 5,4,3,1,2<br>B. 5,3,1,2,4<br>C. 4,2,1,3,5<br>D. 4,1,3,2,5]::(D)	• D序列：输出4后输出1<br>• 但1入队时在队列另一端 → 1输出前必须先将2,3,4,5出队（违反序列要求）<br>• <strong>核心限制</strong>：元素必须按入队顺序连续出队	86