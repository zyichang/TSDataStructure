[01. 栈的应用不包括()。<br>A.递归<br>B.表达式求值<br>C.括号匹配<br>D.缓冲区]::(D)	1. 缓冲区用<strong>队列实现</strong>（如打印缓冲区）<br>2. A/B/C均为栈的典型应用（递归调用栈、表达式求值、括号匹配）	97
[02. 表达式a*(b+c)-d的后缀表达式是()。<br>A.abcd*+-<br>B.abc+*d-<br>C.abc*+d-<br>D.--*abcd]::(B)	• 转换规则：<strong>操作符紧跟操作数</strong><br>• 步骤：<br>  (1) b+c → bc+<br>  (2) a*(bc+) → abc+*<br>  (3) abc+*-d → abc+*d-	97
[03. 下面()用到了队列。<br>A.括号匹配<br>B.表达式求值<br>C.递归<br>D.FIFO页面替换算法]::(D)	• <strong>FIFO页面替换算法</strong>基于队列实现<br>• 其他选项均使用栈（栈保存临时状态）	97
[04. 利用栈求表达式的值时，设立运算数栈OPEN。假设OPEN只有两个存储单元，则在下列表达式中，不会发生溢出的是()。<br>A. A-B*C-D<br>B. (A-B)*C-D<br>C. (A-B*C)-D<br>D. (A-B)*(C-D)]::(B)	• B选项计算过程：<br>  (1) 计算A-B → R1（栈深1）<br>  (2) 计算R1*C → R2（栈深1）<br>  (3) 计算R2-D（栈深始终≤2）<br>• 其他选项需≥3存储单元	98
[05. 执行完下列语句段后，i的值为()。<br>int f(int x){return ((x>0)? x*f(x-1):2);}<br>int i;<br>i=f(f(1));<br>A. 2<br>B. 4<br>C. 8<br>D. 无限递归]::(B)	• 递归计算：<br>  f(1)=1*f(0)=1 * 2=2<br>  f(f(1))=f(2)=2*f(1)=2 * 2=4<br>• <strong>递归出口</strong>：x=0时返回2	98
[06. 设有如下递归函数，则计算F(8)需要调用该递归函数的次数为()。<br>int F(int n){if(n<=3) return 1;else return F(n-2)+F(n-4)+1;}<br>A. 7<br>B. 8<br>C. 9<br>D. 10]::(C)	• 递归调用树共9次：<br>  F(8)→F(6)+F(4)+1<br>  F(6)→F(4)+F(2)+1<br>  F(4)→F(2)+F(0)+1<br>• 底层调用F(1)-F(3)直接返回	98
[07. 设有如下递归函数，在func(func(5))的执行过程中，第4个被执行的func函数是()。<br>int func(int x){if(x<=3) return 2;else return func(x-2)+func(x-4);}<br>A. func(2)<br>B. func(3)<br>C. func(4)<br>D. func(5)]::(C)	• 执行顺序：<br>  1.func(5)<br>  2.func(3)<br>  3.func(1)<br>  4.func(4)（第4个执行）	98
[08. 对于一个问题的递归算法求解和其相对应的非递归算法求解，()。<br>A. 递归算法通常效率高一些<br>B. 非递归算法通常效率高一些<br>C. 两者相同<br>D. 无法比较]::(B)	• <strong>递归算法有额外开销</strong>：活动记录压栈/出栈<br>• 非递归算法<strong>避免重复计算</strong>（如斐波那契数列）	98
[09. 执行函数时，其局部变量一般采用()进行存储。<br>A. 树形结构<br>B. 静态链表<br>C. 栈结构<br>D. 队列结构]::(C)	• <strong>函数调用栈</strong>存储：<br>  1. 局部变量<br>  2. 返回地址<br>  3. 参数表<br>• 后进先出特性匹配函数调用顺序	98
[10. 执行()操作时，需要使用队列作为辅助存储空间。<br>A. 查找散列（哈希）表<br>B. 广度优先搜索图<br>C. 前序（根）遍历二叉树<br>D. 深度优先搜索图]::(B)	• <strong>广度优先搜索</strong>（BFS）需队列保存待访问结点<br>• 深度优先搜索（DFS）用栈实现	98
[11. 下列说法中，正确的是()。<br>A. 消除递归不一定需要使用栈<br>B. 对同一输入序列进行两组不同的合法入栈和出栈组合操作，所得的输出序列也一定相同<br>C. 通常使用队列来处理函数或过程调用<br>D. 队列和栈都是运算受限的线性表，只允许在表的两端进行运算]::(A)	• <strong>尾递归可转为循环</strong>（无需栈）<br>• B错：不同操作序列输出不同<br>• C错：函数调用用栈<br>• D错：栈仅允许一端操作	98
[12. [2009统考真题]为解决计算机主机与打印机之间速度不匹配的问题，通常设置一个打印数据缓冲区，主机将要输出的数据依次写入该缓冲区，而打印机则依次从该缓冲区中取出数据。该缓冲区的逻辑结构应该是()。<br>A. 栈<br>B. 队列<br>C. 树<br>D. 图]::(B)	• 缓冲区需<strong>保持数据顺序</strong>（先进先出）<br>• 树/图无法保证顺序，栈是后进先出	98
[13. [2012统考真题]已知常数符号包括“+”“-”“*”“/”和“()”。将中缀表达式a+b-a*((c+d)/e-f)+g转换为等价的后缀表达式ab+acd+e/f-+g-时，用栈来存放暂时还不能确定运算次序的操作符。栈初始时为空时，转换过程中同时保存在栈中的操作符的最大个数是()。<br>A. 5<br>B. 7<br>C. 8<br>D. 11]::(A)	• 栈中操作符峰值：5个<br>• 关键点：处理嵌套括号<code>((c+d)/e-f)</code>时<br>  栈内：<code>[+, -, *, (, (]</code>	98
[14. [2014统考真题]假设栈初始为空，将中缀表达式a/b+(c*d-e*f)/g转换为等价的后缀表达式的过程中，当扫描到f时，栈中的元素依次是()。<br>A. +(*-<br>B. +(-*<br>C. /+(*-*<br>D. +-*]::(B)	• 当扫描到f：<br>  栈内符号：<code>+ ( - *</code><br>• 后缀表达式当前：<code>ab/cd*ef</code>	99
[15. [2015统考真题]已知程序如下：<br>int S(int n){return(n<=0)?0:S(n-1)+n;}<br>void main(){cout<<S(1);}<br>程序运行时使用栈来保存调用过程的信息，自栈底到栈顶保存的信息依次对应的是()。<br>A. main()→S(1)→S(0)<br>B. S(0)→S(1)→main()<br>C. main()→S(0)→S(1)<br>D. S(1)→S(0)→main()]::(A)	• <strong>调用顺序</strong>：<br>  1.main()调用S(1)<br>  2.S(1)调用S(0)<br>• 栈底→栈顶：main() → S(1) → S(0)	99
[16. [2016统考真题]设有如下图所示的火车车轨，入口和出口之间有n条轨道，列车的行进方向均为从左至右，列车可驶入任意一条轨道。现有编号为1~9的9列列车，驶入的次序依次是8,4,2,5,3,9,1,6,7。若期望驶出的次序依次为1~9，则n至少是()。<br>A. 2<br>B. 3<br>C. 4<br>D. 5]::(C)	• 需<strong>4条轨道</strong>实现顺序调整：<br>  轨道1：8,9<br>  轨道2：4,5,6,7<br>  轨道3：2,3<br>  轨道4：1<br>• 关键：1必须单独轨道（编号最小却最早出）	99
[17. [2017统考真题]下列关于栈的叙述中，错误的是()。<br>I. 采用非递归方式重写递归程序时必须使用栈<br>II. 函数调用时，系统要用栈保存必要的信息<br>III. 只要确定了入栈次序，即可确定出栈次序<br>IV. 栈是一种受限的线性表，允许在其两端进行操作<br>A. 仅I<br>B. 仅I、II、III<br>C. 仅I、III、IV<br>D. 仅II、III、IV]::(C)	• <strong>错误陈述</strong>：<br>  I：尾递归可转循环（无需栈）<br>  III：不同操作序列产生不同输出（如入栈1,2可出栈2,1或1,2）<br>  IV：栈只允许一端操作<br>• II正确：函数调用栈保存返回地址/局部变量	99
[18. [2018统考真题]若栈S1中保存整数，栈S2中保存运算符，函数F()依次执行下述各步操作：<br>1)从S1中依次弹出两个操作数a和b<br>2)从S2中弹出一个运算符op<br>3)执行相应的运算b op a<br>4)将运算结果压入S1中<br>假定S1中的操作数依次是5,8,3,2(2在栈顶)，S2中的运算符依次是*、-、+(+在栈顶)。调用3次F()后，S1栈顶保存的值是()。<br>A. -15<br>B. 15<br>C. -20<br>D. 20]::(B)	• 执行过程：<br>  第1次：3+2=5 → S1=[5,8,5]<br>  第2次：8-5=3 → S1=[5,3]<br>  第3次：5 * 3=15 → S1=[15]<br>• 栈顶值：15	99